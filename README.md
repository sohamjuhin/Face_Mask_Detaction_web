# Face_Mask_Detaction_web
Face_Mask_Detaction_web screen short
------------------------------------
![Screenshot 2021-07-01 at 4 32 28 PM](https://user-images.githubusercontent.com/54598380/157693896-58c294e4-100f-4c52-adf5-a2764aef7c80.png)
   ##PROJECT  OBJECTIVE##
 ------------------------------ 

After the new Coronavirus disease (COVID-19) case spread rapidly in Wuhan-China in December 2019, World Health Organization (WHO) confirmed that this is a dangerous virus which can be spreading from humans to humans through droplets and airborne. As for the prevention, wearing a face mask is essentials while going outside or meeting to others. However, some irresponsible people refuse to wear face mask with so many excuses. Moreover, developing the face mask detector is very crucial in this case. This paper aims to develop the face mask detector which is able to detect any kinds of face mask. In order to detect the face mask, a YOLO V4 deep learning has been chosen as the mask detection algorithm. The experimental results have been done in real-time application system has been installed at computer. From the experimental results, this device is able to detect the people who wear or do not wear the face mask accurately even if they are moving to various position.


1) COVID FREE COMMUNITIY,AND OPEN SOURSE PROJECT DEVOLPMENT,PROTABALITIY,COST COFOTABLITIY.
2)OUR SYSTEM AVAILABLE TOW TYPE OF VERSION:-
 i)WEB IN DESKTOP 
II)ANDROID APPLICATION IN WEB

---------------------------------------------------------------------------------------------------------------------------------------------------
##Software##
---------------
Classical waterfall model is the basic software development life cycle model. It is very simple but idealistic. Earlier this model was very popular but nowadays it is not used. But it is very important because all the other software development life cycle models are based on the classical waterfall model.
Classical waterfall model divides the life cycle into a set of phases. This model considers that one phase can be started after completion of the previous phase. That is the output of one phase will be the input to the next phase. Thus the development process can be considered as a sequential flow in the waterfall. Here the phases do not overlap with each other. The different sequential phases of the classical waterfall model are shown in the below figure

![image](https://user-images.githubusercontent.com/54598380/157694397-cc314e2f-6831-4e24-8558-9a83f6a5a47d.png)
Let us now learn about each of these phases in brief details:

Feasibility Study: The main goal of this phase is to determine whether it would be financially and technically feasible to develop the software.
The feasibility study involves understanding the problem and then determine the various possible strategies to solve the problem. These different identified solutions are analyzed based on their benefits and drawbacks, The best solution is chosen and all the other phases are carried out as per this solution strategy.
Requirements analysis and specification: The aim of the requirement analysis and specification phase is to understand the exact requirements of the customer and document them properly. This phase consists of two different activities.
Requirement gathering and analysis: Firstly all the requirements regarding the software are gathered from the customer and then the gathered requirements are analyzed. The goal of the analysis part is to remove incompleteness (an incomplete requirement is one in which some parts of the actual requirements have been omitted) and inconsistencies (inconsistent requirement is one in which some part of the requirement contradicts with some other part).


Requirement specification: These analyzed requirements are documented in a software requirement specification (SRS) document. SRS document serves as a contract between development team and customers. Any future dispute between the customers and the developers can be settled by examining the SRS document.
Design: The aim of the design phase is to transform the requirements specified in the SRS document into a structure that is suitable for implementation in some programming language.

Coding and Unit testing: In coding phase software design is translated into source code using any suitable programming language. Thus each designed module is coded. The aim of the unit testing phase is to check whether each module is working properly or not.Integration and System testing: Integration of different modules are undertaken soon after they have been coded and unit tested. Integration of various modules is carried out incrementally over a number of steps. During each integration step, previously planned modules are added to the partially integrated system and the resultant system is tested. Finally, after all the modules have been successfully integrated and tested, the full working system is obtained and system testing is carried out on this.
ystem testing consists three different kinds of testing activities as described 
below :
Alpha testing: Alpha testing is the system testing performed by the development team.
Beta testing: Beta testing is the system testing performed by a friendly set of customers.
Acceptance testing: After the software has been delivered, the customer performed the acceptance testing to determine whether to accept the delivered software or to reject it.
Maintainence: Maintenance is the most important phase of a software life cycle. The effort spent on maintenance is the 60% of the total effort spent to develop a full software. There are basically three types of maintenance :
Corrective Maintenance: This type of maintenance is carried out to correct errors that were not discovered during the product development phase.


Perfective Maintenance: This type of maintenance is carried out to enhance the functionalities of the system based on the customerâ€™s request.
Adaptive Maintenance: Adaptive maintenance is usually required for porting the software to work in a new environment such as work on a new computer platform or with a new operating system.
Advantages of Classical Waterfall Model








Classical waterfall model is an idealistic model for software development.
 It is very simple, so it can be considered as the basis for other software development life cycle models. Below are some of the major advantages of this SDLC model:

This model is very simple and is easy to understand.
Phases in this model are processed one at a time.
Each stage in the model is clearly defined.
This model has very clear and well undestood milestones.
Process, actions and results are very well documented.
Reinforces good habits: define-before- design,
design-before-code.
This model works well for smaller projects and projects where requirements are well
understood.
Drawbacks of Classical Waterfall Model














Classical waterfall model suffers from various shortcomings, basically we canâ€™t use it in real projects, but we use other software development lifecycle models which are based on the classical waterfall model. Below are some major drawbacks of this model:

No feedback path: In classical waterfall model evolution of a software from one phase to another phase is like a waterfall. It assumes that no error is ever committed by developers during any phases. Therefore, it does not incorporate any mechanism for error correction.
Difficult to accommodate change requests: This model assumes that all the customer requirements can be completely and correctly defined at the beginning of the project, but actually customersâ€™ requirements keep on changing with time. It is difficult to accommodate any change requests after the requirements specification phase is complete.


No overlapping of phases: This model recommends that new phase can start only after the completion of the previous phase. But in real projects, this canâ€™t be maintained. To increase the efficiency and reduce the cost, phases may overlap.





##TOOLS##
------------



CORE SYSTEM                                           
               PYTHON
EDITOR,TOOLS
           PYCHARM,ANACONDA,JUPTER,ATOM
WEB SIDE DIGINE ,DEVOLOPMENT
                                  JAVASCRIPT,HTML,BOOSTRAP, CSS
EDITOR
                          SUBLINETXT
ANDROID
              JAVA
EDITOR,TOOLS
            ANDROID STOUIDO 
  DATABASE SYSTEM & WEBBROWSER
                              PHP,FIEBASED
CHOROME,FIREFOX

---------------------------------------------------------------------------------------------------------


  OUR CORE FACE MASK DETACTION SYSTEM(Python)

We are using python,cov19 Traniy chat, opencv,kara etc, in OUR CORE FACE MASK DETACTION SYSTEM. 
ğ™ğ™–ğ™˜ğ™š ğ™ˆğ™–ğ™¨ğ™  ğ˜¿ğ™šğ™©ğ™šğ™˜ğ™©ğ™¤ğ™§: ğ™„ ğ™˜ğ™§ğ™šğ™–ğ™©ğ™šğ™™ ğ™– ğ™¨ğ™ğ™¢ğ™¥ğ™¡ğ™š ğ™ğ™–ğ™˜ğ™š ğ™ˆğ™–ğ™¨ğ™  ğ˜¿ğ™šğ™©ğ™šğ™˜ğ™©ğ™¤ğ™§ ğ™¬ğ™ğ™©ğ™ ğ™ğ™šğ™£ğ™¨ğ™¤ğ™§ğ™›ğ™¡ğ™¤ğ™¬ (ğ™¢ğ™¡ğŸ“.ğ™Ÿğ™¨ ğ™–ğ™£ğ™™ ğ™¥ğŸ“ğ™Ÿğ™¨).

Right now it is very important to wear facemasks, oftentimes we donâ€™t really know if we are wearing our masks correctly. It is really important to make sure that the masks cover our mouths, chins, and noses completely.

ğŸ‘“Features:
- integrated WHO: how to use masks guide

- recognizes: mask on (107 sample images)

- recognizes: no mask (100 sample images)

- recognizes: nose visible (127 sample images)

##ğŸ’»Dataset:##
------------------
Correct: mask on (107 sample images)

Wrong: no mask (100 sample images)

Wrong: nose visible (127 sample images)







